'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialState = void 0;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = asyncActionsState;

var _constants = require('./constants');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = exports.initialState = {
  asyncActionsStates: [],
  indexes: {},
  groups: {},
  errorsCount: 0,
  successCount: 0,
  failedActionsIndexes: [],
  digested: 0
};

function asyncActionsState() {
  var state = arguments.length <= 0 || arguments[0] === void 0 ? initialState : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];

  var newState = state;

  if (action[_constants.ASYNC_UTILS_MARKER]) {
    var _ret = function () {
      var asyncState = action[_constants.ASYNC_UTILS_STATE];
      var error = action.error || null;
      var asyncStateFor = action[_constants.ASYNC_UTILS_STATE_FOR];
      var asyncStateGroup = action[_constants.ASYNC_UTILS_STATE_GROUP];
      var previousState = void 0;

      var index = void 0;

      newState = {
        asyncActionsStates: state.asyncActionsStates.slice(0),
        indexes: _extends({}, state.indexes),
        groups: _extends({}, state.groups),
        errorsCount: state.errorsCount,
        failedActionsIndexes: state.failedActionsIndexes.slice(0),
        successCount: state.successCount,
        digested: state.digested
      };

      // look for asyncState in indexes
      if (typeof newState.indexes[asyncStateFor] !== 'undefined') {
        index = newState.indexes[asyncStateFor];
        previousState = _extends({}, newState.asyncActionsStates[index]);
      } else {
        // search in the array and create indexes
        newState.asyncActionsStates.forEach(function (v, i) {
          if (v[_constants.ASYNC_UTILS_STATE_FOR] === asyncStateFor) {
            index = i;
            previousState = _extends({}, newState.asyncActionsStates[index]);
          }

          newState.indexes[v[_constants.ASYNC_UTILS_STATE_FOR]] = i;
        });
      }

      // if a pending action become INVALIDATED before being completed,
      // when DONE or FAILURE state will be dispatched
      // simply ignore them
      if (previousState && asyncState !== _constants.PENDING && previousState.state === _constants.INVALIDATED) {
        return {
          v: newState
        };
      }

      // create new
      if (typeof index === 'undefined') {
        var _newActionState;

        var newActionState = (_newActionState = {}, _defineProperty(_newActionState, _constants.ASYNC_UTILS_STATE_FOR, asyncStateFor), _defineProperty(_newActionState, 'state', asyncState), _defineProperty(_newActionState, 'error', error), _newActionState);
        newState.asyncActionsStates.push(newActionState);

        // save index
        newState.indexes[asyncStateFor] = newState.asyncActionsStates.length - 1;
        index = newState.asyncActionsStates.length - 1;

        // save in group
        if (asyncStateGroup) {
          if (!newState.groups[asyncStateGroup]) {
            newState.groups[asyncStateGroup] = [index];
          } else {
            newState.groups[asyncStateGroup] = newState.groups[asyncStateGroup].slice(0);
            newState.groups[asyncStateGroup].push(index);
          }
        }
      } else {
        var _newState$asyncAction;

        newState.asyncActionsStates[index] = (_newState$asyncAction = {}, _defineProperty(_newState$asyncAction, _constants.ASYNC_UTILS_STATE_FOR, asyncStateFor), _defineProperty(_newState$asyncAction, 'state', asyncState), _defineProperty(_newState$asyncAction, 'error', error), _newState$asyncAction);
      }

      // if an async action was digested and a new pending action is requested,
      // reset digested, successCount and errorsCount as the action was never requested before
      if (previousState &&

      // prevent variables reset in case of simple passage from PENDING to other state
      // in that case the action has to be digested yet
      previousState.state !== _constants.PENDING &&

      // prevent pending action dispatched twice
      previousState.state !== asyncState) {
        if (asyncState !== _constants.INVALIDATED) {
          newState.digested--;
        }

        if (previousState.state === _constants.DONE) {
          newState.successCount--;
        }

        if (previousState.state === _constants.FAILURE) {
          newState.errorsCount--;
          newState.failedActionsIndexes.splice(newState.failedActionsIndexes.indexOf(index), 1);
        }
      }

      // update vars
      if (asyncState === _constants.INVALIDATED && (!previousState || previousState.state === _constants.PENDING)) {
        newState.digested++;
      }

      if (asyncState === _constants.DONE && (!previousState || previousState.state !== _constants.DONE)) {
        newState.digested++;
        newState.successCount++;
      }

      if (asyncState === _constants.FAILURE && (!previousState || previousState.state !== _constants.FAILURE)) {
        newState.digested++;
        newState.errorsCount++;
        newState.failedActionsIndexes.push(index);
      }
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  return newState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hc3luY0FjdGlvbnNTdGF0ZVJlZHVjZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7a0JBcUJ3Qjs7QUFyQnhCOzs7O0FBV08sSUFBTSxzQ0FBZTtBQUMxQixzQkFBb0IsRUFBcEI7QUFDQSxXQUFTLEVBQVQ7QUFDQSxVQUFRLEVBQVI7QUFDQSxlQUFhLENBQWI7QUFDQSxnQkFBYyxDQUFkO0FBQ0Esd0JBQXNCLEVBQXRCO0FBQ0EsWUFBVSxDQUFWO0NBUFc7O0FBVUUsU0FBUyxpQkFBVCxHQUE4RDtNQUFuQywyREFBUSw0QkFBMkI7TUFBYiw0REFBUyxrQkFBSTs7QUFDM0UsTUFBSSxXQUFXLEtBQVgsQ0FEdUU7O0FBRzNFLE1BQUkscUNBQUosRUFBZ0M7O0FBQzlCLFVBQU0sYUFBYSxvQ0FBYjtBQUNOLFVBQU0sUUFBUSxPQUFPLEtBQVAsSUFBZ0IsSUFBaEI7QUFDZCxVQUFNLGdCQUFnQix3Q0FBaEI7QUFDTixVQUFNLGtCQUFrQiwwQ0FBbEI7QUFDTixVQUFJLHNCQUFKOztBQUVBLFVBQUksY0FBSjs7QUFFQSxpQkFBVztBQUNULDRCQUFvQixNQUFNLGtCQUFOLENBQXlCLEtBQXpCLENBQStCLENBQS9CLENBQXBCO0FBQ0EsOEJBQWMsTUFBTSxPQUFOLENBQWQ7QUFDQSw2QkFBYSxNQUFNLE1BQU4sQ0FBYjtBQUNBLHFCQUFhLE1BQU0sV0FBTjtBQUNiLDhCQUFzQixNQUFNLG9CQUFOLENBQTJCLEtBQTNCLENBQWlDLENBQWpDLENBQXRCO0FBQ0Esc0JBQWMsTUFBTSxZQUFOO0FBQ2Qsa0JBQVUsTUFBTSxRQUFOO09BUFo7OztBQVdBLFVBQUksT0FBTyxTQUFTLE9BQVQsQ0FBaUIsYUFBakIsQ0FBUCxLQUEyQyxXQUEzQyxFQUF3RDtBQUMxRCxnQkFBUSxTQUFTLE9BQVQsQ0FBaUIsYUFBakIsQ0FBUixDQUQwRDtBQUUxRCx3QkFBZ0IsU0FBYyxFQUFkLEVBQWtCLFNBQVMsa0JBQVQsQ0FBNEIsS0FBNUIsQ0FBbEIsQ0FBaEIsQ0FGMEQ7T0FBNUQsTUFHTzs7QUFFTCxpQkFBUyxrQkFBVCxDQUE0QixPQUE1QixDQUFvQyxVQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDNUMsY0FBSSx3Q0FBNkIsYUFBN0IsRUFBNEM7QUFDOUMsb0JBQVEsQ0FBUixDQUQ4QztBQUU5Qyw0QkFBZ0IsU0FBYyxFQUFkLEVBQWtCLFNBQVMsa0JBQVQsQ0FBNEIsS0FBNUIsQ0FBbEIsQ0FBaEIsQ0FGOEM7V0FBaEQ7O0FBS0EsbUJBQVMsT0FBVCxDQUFpQixtQ0FBakIsSUFBNkMsQ0FBN0MsQ0FONEM7U0FBVixDQUFwQyxDQUZLO09BSFA7Ozs7O0FBa0JBLFVBQ0UsaUJBQ0EsaUNBREEsSUFFQSxjQUFjLEtBQWQsMkJBRkEsRUFHQTtBQUNBO2FBQU87U0FBUCxDQURBO09BSkY7OztBQVNBLFVBQUksT0FBTyxLQUFQLEtBQWlCLFdBQWpCLEVBQThCOzs7QUFDaEMsWUFBTSwyR0FDcUIsMERBQ2xCLHVEQUNQLHdCQUhJLENBRDBCO0FBTWhDLGlCQUFTLGtCQUFULENBQTRCLElBQTVCLENBQWlDLGNBQWpDOzs7QUFOZ0MsZ0JBU2hDLENBQVMsT0FBVCxDQUFpQixhQUFqQixJQUFrQyxTQUFTLGtCQUFULENBQTRCLE1BQTVCLEdBQXFDLENBQXJDLENBVEY7QUFVaEMsZ0JBQVEsU0FBUyxrQkFBVCxDQUE0QixNQUE1QixHQUFxQyxDQUFyQzs7O0FBVndCLFlBYTVCLGVBQUosRUFBcUI7QUFDbkIsY0FBSSxDQUFDLFNBQVMsTUFBVCxDQUFnQixlQUFoQixDQUFELEVBQW1DO0FBQ3JDLHFCQUFTLE1BQVQsQ0FBZ0IsZUFBaEIsSUFBbUMsQ0FBQyxLQUFELENBQW5DLENBRHFDO1dBQXZDLE1BRU87QUFDTCxxQkFBUyxNQUFULENBQWdCLGVBQWhCLElBQW1DLFNBQVMsTUFBVCxDQUFnQixlQUFoQixFQUFpQyxLQUFqQyxDQUF1QyxDQUF2QyxDQUFuQyxDQURLO0FBRUwscUJBQVMsTUFBVCxDQUFnQixlQUFoQixFQUFpQyxJQUFqQyxDQUFzQyxLQUF0QyxFQUZLO1dBRlA7U0FERjtPQWJGLE1BcUJPOzs7QUFDTCxpQkFBUyxrQkFBVCxDQUE0QixLQUE1QiwwR0FDMkIsZ0VBQ2xCLDZEQUNQLDhCQUhGLENBREs7T0FyQlA7Ozs7QUErQkEsVUFDRTs7OztBQUlBLG9CQUFjLEtBQWQsdUJBSkE7OztBQU9BLG9CQUFjLEtBQWQsS0FBd0IsVUFBeEIsRUFDQTtBQUNBLFlBQ0UscUNBREYsRUFFRTtBQUNBLG1CQUFTLFFBQVQsR0FEQTtTQUZGOztBQU1BLFlBQUksY0FBYyxLQUFkLG9CQUFKLEVBQWtDO0FBQ2hDLG1CQUFTLFlBQVQsR0FEZ0M7U0FBbEM7O0FBSUEsWUFBSSxjQUFjLEtBQWQsdUJBQUosRUFBcUM7QUFDbkMsbUJBQVMsV0FBVCxHQURtQztBQUVuQyxtQkFBUyxvQkFBVCxDQUE4QixNQUE5QixDQUFxQyxTQUFTLG9CQUFULENBQThCLE9BQTlCLENBQXNDLEtBQXRDLENBQXJDLEVBQW1GLENBQW5GLEVBRm1DO1NBQXJDO09BcEJGOzs7QUEyQkEsVUFBSSwwQ0FBK0IsQ0FBQyxhQUFELElBQWtCLGNBQWMsS0FBZCx1QkFBbEIsQ0FBL0IsRUFBbUY7QUFDckYsaUJBQVMsUUFBVCxHQURxRjtPQUF2Rjs7QUFJQSxVQUFJLG1DQUF3QixDQUFDLGFBQUQsSUFBa0IsY0FBYyxLQUFkLG9CQUFsQixDQUF4QixFQUF5RTtBQUMzRSxpQkFBUyxRQUFULEdBRDJFO0FBRTNFLGlCQUFTLFlBQVQsR0FGMkU7T0FBN0U7O0FBS0EsVUFBSSxzQ0FBMkIsQ0FBQyxhQUFELElBQWtCLGNBQWMsS0FBZCx1QkFBbEIsQ0FBM0IsRUFBK0U7QUFDakYsaUJBQVMsUUFBVCxHQURpRjtBQUVqRixpQkFBUyxXQUFULEdBRmlGO0FBR2pGLGlCQUFTLG9CQUFULENBQThCLElBQTlCLENBQW1DLEtBQW5DLEVBSGlGO09BQW5GO1FBbEg4Qjs7O0dBQWhDOztBQXlIQSxTQUFPLFFBQVAsQ0E1SDJFO0NBQTlEIiwiZmlsZSI6ImFzeW5jQWN0aW9uc1N0YXRlUmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFTWU5DX1VUSUxTX01BUktFUixcbiAgQVNZTkNfVVRJTFNfU1RBVEUsXG4gIEFTWU5DX1VUSUxTX1NUQVRFX0ZPUixcbiAgQVNZTkNfVVRJTFNfU1RBVEVfR1JPVVAsXG4gIFBFTkRJTkcsXG4gIERPTkUsXG4gIEZBSUxVUkUsXG4gIElOVkFMSURBVEVELFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGFzeW5jQWN0aW9uc1N0YXRlczogW10sXG4gIGluZGV4ZXM6IHt9LFxuICBncm91cHM6IHt9LFxuICBlcnJvcnNDb3VudDogMCxcbiAgc3VjY2Vzc0NvdW50OiAwLFxuICBmYWlsZWRBY3Rpb25zSW5kZXhlczogW10sXG4gIGRpZ2VzdGVkOiAwLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXN5bmNBY3Rpb25zU3RhdGUoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbiA9IHt9KSB7XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChhY3Rpb25bQVNZTkNfVVRJTFNfTUFSS0VSXSkge1xuICAgIGNvbnN0IGFzeW5jU3RhdGUgPSBhY3Rpb25bQVNZTkNfVVRJTFNfU1RBVEVdO1xuICAgIGNvbnN0IGVycm9yID0gYWN0aW9uLmVycm9yIHx8IG51bGw7XG4gICAgY29uc3QgYXN5bmNTdGF0ZUZvciA9IGFjdGlvbltBU1lOQ19VVElMU19TVEFURV9GT1JdO1xuICAgIGNvbnN0IGFzeW5jU3RhdGVHcm91cCA9IGFjdGlvbltBU1lOQ19VVElMU19TVEFURV9HUk9VUF07XG4gICAgbGV0IHByZXZpb3VzU3RhdGU7XG5cbiAgICBsZXQgaW5kZXg7XG5cbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIGFzeW5jQWN0aW9uc1N0YXRlczogc3RhdGUuYXN5bmNBY3Rpb25zU3RhdGVzLnNsaWNlKDApLFxuICAgICAgaW5kZXhlczogeyAuLi5zdGF0ZS5pbmRleGVzIH0sXG4gICAgICBncm91cHM6IHsgLi4uc3RhdGUuZ3JvdXBzIH0sXG4gICAgICBlcnJvcnNDb3VudDogc3RhdGUuZXJyb3JzQ291bnQsXG4gICAgICBmYWlsZWRBY3Rpb25zSW5kZXhlczogc3RhdGUuZmFpbGVkQWN0aW9uc0luZGV4ZXMuc2xpY2UoMCksXG4gICAgICBzdWNjZXNzQ291bnQ6IHN0YXRlLnN1Y2Nlc3NDb3VudCxcbiAgICAgIGRpZ2VzdGVkOiBzdGF0ZS5kaWdlc3RlZCxcbiAgICB9O1xuXG4gICAgLy8gbG9vayBmb3IgYXN5bmNTdGF0ZSBpbiBpbmRleGVzXG4gICAgaWYgKHR5cGVvZiBuZXdTdGF0ZS5pbmRleGVzW2FzeW5jU3RhdGVGb3JdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaW5kZXggPSBuZXdTdGF0ZS5pbmRleGVzW2FzeW5jU3RhdGVGb3JdO1xuICAgICAgcHJldmlvdXNTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIG5ld1N0YXRlLmFzeW5jQWN0aW9uc1N0YXRlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZWFyY2ggaW4gdGhlIGFycmF5IGFuZCBjcmVhdGUgaW5kZXhlc1xuICAgICAgbmV3U3RhdGUuYXN5bmNBY3Rpb25zU3RhdGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgaWYgKHZbQVNZTkNfVVRJTFNfU1RBVEVfRk9SXSA9PT0gYXN5bmNTdGF0ZUZvcikge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBwcmV2aW91c1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3U3RhdGUuYXN5bmNBY3Rpb25zU3RhdGVzW2luZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdTdGF0ZS5pbmRleGVzW3ZbQVNZTkNfVVRJTFNfU1RBVEVfRk9SXV0gPSBpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgYSBwZW5kaW5nIGFjdGlvbiBiZWNvbWUgSU5WQUxJREFURUQgYmVmb3JlIGJlaW5nIGNvbXBsZXRlZCxcbiAgICAvLyB3aGVuIERPTkUgb3IgRkFJTFVSRSBzdGF0ZSB3aWxsIGJlIGRpc3BhdGNoZWRcbiAgICAvLyBzaW1wbHkgaWdub3JlIHRoZW1cbiAgICBpZiAoXG4gICAgICBwcmV2aW91c1N0YXRlICYmXG4gICAgICBhc3luY1N0YXRlICE9PSBQRU5ESU5HICYmXG4gICAgICBwcmV2aW91c1N0YXRlLnN0YXRlID09PSBJTlZBTElEQVRFRFxuICAgICkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXdcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgbmV3QWN0aW9uU3RhdGUgPSB7XG4gICAgICAgIFtBU1lOQ19VVElMU19TVEFURV9GT1JdOiBhc3luY1N0YXRlRm9yLFxuICAgICAgICBzdGF0ZTogYXN5bmNTdGF0ZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgICAgbmV3U3RhdGUuYXN5bmNBY3Rpb25zU3RhdGVzLnB1c2gobmV3QWN0aW9uU3RhdGUpO1xuXG4gICAgICAvLyBzYXZlIGluZGV4XG4gICAgICBuZXdTdGF0ZS5pbmRleGVzW2FzeW5jU3RhdGVGb3JdID0gbmV3U3RhdGUuYXN5bmNBY3Rpb25zU3RhdGVzLmxlbmd0aCAtIDE7XG4gICAgICBpbmRleCA9IG5ld1N0YXRlLmFzeW5jQWN0aW9uc1N0YXRlcy5sZW5ndGggLSAxO1xuXG4gICAgICAvLyBzYXZlIGluIGdyb3VwXG4gICAgICBpZiAoYXN5bmNTdGF0ZUdyb3VwKSB7XG4gICAgICAgIGlmICghbmV3U3RhdGUuZ3JvdXBzW2FzeW5jU3RhdGVHcm91cF0pIHtcbiAgICAgICAgICBuZXdTdGF0ZS5ncm91cHNbYXN5bmNTdGF0ZUdyb3VwXSA9IFtpbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U3RhdGUuZ3JvdXBzW2FzeW5jU3RhdGVHcm91cF0gPSBuZXdTdGF0ZS5ncm91cHNbYXN5bmNTdGF0ZUdyb3VwXS5zbGljZSgwKTtcbiAgICAgICAgICBuZXdTdGF0ZS5ncm91cHNbYXN5bmNTdGF0ZUdyb3VwXS5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZS5hc3luY0FjdGlvbnNTdGF0ZXNbaW5kZXhdID0ge1xuICAgICAgICBbQVNZTkNfVVRJTFNfU1RBVEVfRk9SXTogYXN5bmNTdGF0ZUZvcixcbiAgICAgICAgc3RhdGU6IGFzeW5jU3RhdGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBhc3luYyBhY3Rpb24gd2FzIGRpZ2VzdGVkIGFuZCBhIG5ldyBwZW5kaW5nIGFjdGlvbiBpcyByZXF1ZXN0ZWQsXG4gICAgLy8gcmVzZXQgZGlnZXN0ZWQsIHN1Y2Nlc3NDb3VudCBhbmQgZXJyb3JzQ291bnQgYXMgdGhlIGFjdGlvbiB3YXMgbmV2ZXIgcmVxdWVzdGVkIGJlZm9yZVxuICAgIGlmIChcbiAgICAgIHByZXZpb3VzU3RhdGUgJiZcblxuICAgICAgLy8gcHJldmVudCB2YXJpYWJsZXMgcmVzZXQgaW4gY2FzZSBvZiBzaW1wbGUgcGFzc2FnZSBmcm9tIFBFTkRJTkcgdG8gb3RoZXIgc3RhdGVcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB0aGUgYWN0aW9uIGhhcyB0byBiZSBkaWdlc3RlZCB5ZXRcbiAgICAgIHByZXZpb3VzU3RhdGUuc3RhdGUgIT09IFBFTkRJTkcgJiZcblxuICAgICAgLy8gcHJldmVudCBwZW5kaW5nIGFjdGlvbiBkaXNwYXRjaGVkIHR3aWNlXG4gICAgICBwcmV2aW91c1N0YXRlLnN0YXRlICE9PSBhc3luY1N0YXRlXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGFzeW5jU3RhdGUgIT09IElOVkFMSURBVEVEXG4gICAgICApIHtcbiAgICAgICAgbmV3U3RhdGUuZGlnZXN0ZWQtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUuc3RhdGUgPT09IERPTkUpIHtcbiAgICAgICAgbmV3U3RhdGUuc3VjY2Vzc0NvdW50LS07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlLnN0YXRlID09PSBGQUlMVVJFKSB7XG4gICAgICAgIG5ld1N0YXRlLmVycm9yc0NvdW50LS07XG4gICAgICAgIG5ld1N0YXRlLmZhaWxlZEFjdGlvbnNJbmRleGVzLnNwbGljZShuZXdTdGF0ZS5mYWlsZWRBY3Rpb25zSW5kZXhlcy5pbmRleE9mKGluZGV4KSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHZhcnNcbiAgICBpZiAoYXN5bmNTdGF0ZSA9PT0gSU5WQUxJREFURUQgJiYgKCFwcmV2aW91c1N0YXRlIHx8IHByZXZpb3VzU3RhdGUuc3RhdGUgPT09IFBFTkRJTkcpKSB7XG4gICAgICBuZXdTdGF0ZS5kaWdlc3RlZCsrO1xuICAgIH1cblxuICAgIGlmIChhc3luY1N0YXRlID09PSBET05FICYmICghcHJldmlvdXNTdGF0ZSB8fCBwcmV2aW91c1N0YXRlLnN0YXRlICE9PSBET05FKSkge1xuICAgICAgbmV3U3RhdGUuZGlnZXN0ZWQrKztcbiAgICAgIG5ld1N0YXRlLnN1Y2Nlc3NDb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChhc3luY1N0YXRlID09PSBGQUlMVVJFICYmICghcHJldmlvdXNTdGF0ZSB8fCBwcmV2aW91c1N0YXRlLnN0YXRlICE9PSBGQUlMVVJFKSkge1xuICAgICAgbmV3U3RhdGUuZGlnZXN0ZWQrKztcbiAgICAgIG5ld1N0YXRlLmVycm9yc0NvdW50Kys7XG4gICAgICBuZXdTdGF0ZS5mYWlsZWRBY3Rpb25zSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iXX0=